"""
This is a callback designed to save the permutations generated by the permutation learning model
it will create a file that contains some statistics on the correct permutation.
"""
from lightning.pytorch.callbacks import Callback
import os
from lightning_toolbox import TrainingModule
from lightning.pytorch import Trainer
import typing as th
import numpy as np
import json
import networkx as nx
from ocd.evaluation import backward_score
import dypy as dy


class SavePermutationResultsCallback(Callback):
    def __init__(
        self,
        save_path: str,
        save_every_n_epochs: th.Optional[int] = None,
        num_samples: int = 1000,
        ordering_to_score_mapping: th.Optional[th.Dict[str, th.Union[float, int]]] = None,
        causal_graph: th.Optional[th.Union[str, nx.DiGraph]] = None,
        # causal_graph_args: th.Optional[dict] = None,
    ):
        self.save_path = save_path
        # create save_path if it does not exist
        if not os.path.exists(save_path):
            os.makedirs(save_path)

        self.save_every_n_epochs = save_every_n_epochs
        self.epoch_counter = 0
        self.num_samples = num_samples

        self.ordering_to_score_mapping = ordering_to_score_mapping
        self.causal_graph = causal_graph
        # self.causal_graph = causal_graph_cls if isinstance(causal_graph_cls, nx.DiGraph) else None
        # if self.causal_graph is None and causal_graph_cls is not None:
        #     causal_graph_args = causal_graph_args if causal_graph_args is not None else {}
        #     self.causal_graph = dy.eval(causal_graph_cls)(**causal_graph_args)

    def _save_results(self, pl_module: TrainingModule, filename: th.Optional[str] = None) -> None:
        filename = filename if filename is not None else f"results-epoch-{self.epoch_counter}"
        filename += ".json"

        # save the results
        perm_model = pl_module.model.permutation_model

        all_permutations = perm_model(
            num_samples=self.num_samples, return_matrix=False, permutation_type="hard", training_module=pl_module
        )["perm_mat"]

        permutation_map = {}
        unique_permutations, counts = np.unique(all_permutations, axis=0, return_counts=True)
        mx = None
        for perm, c in zip(unique_permutations, counts):
            key = "-".join([str(i) for i in perm])
            permutation_map[key] = 1.0 * c / np.sum(counts)
            if mx is None or permutation_map[key] > permutation_map[mx]:
                mx = key

        ret = {}
        if self.causal_graph is not None:
            ret["avg_score"] = backward_score(all_permutations, self.causal_graph)
        if self.ordering_to_score_mapping is not None:
            score = 0.0
            cnt_cumul = 0.0
            for perm, c in permutation_map.items():
                if perm not in self.ordering_to_score_mapping:
                    raise ValueError(f"Permutation {perm} not in ordering_to_score_mapping")
                score += c * self.ordering_to_score_mapping[perm]
                cnt_cumul += c
            ret["avg_score"] = score / cnt_cumul

        ret["permutation_map"], ret["most_common_permutation"] = permutation_map, mx

        saving_path = os.path.join(self.save_path, filename)
        # save res to saving_path
        with open(saving_path, "w") as f:
            json.dump(ret, f, indent=4)

    def on_fit_end(self, trainer: Trainer, pl_module: TrainingModule) -> None:
        self._save_results(pl_module, filename="final-results")
        return super().on_fit_end(trainer, pl_module)

    def on_train_epoch_end(self, trainer: Trainer, pl_module: TrainingModule) -> None:
        self.epoch_counter += 1
        if self.save_every_n_epochs is not None and self.epoch_counter % self.save_every_n_epochs == 0:
            # save the results
            self._save_results(pl_module)

        return super().on_train_epoch_end(trainer, pl_module)
